<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>FCL å…¨æ–¹ä½æŸ¥è¯¢é¢æ¿ v5.1</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <style>
        :root {
            --primary-color: #007bff;
            --primary-hover: #0056b3;
            --background-color: #f4f7f9;
            --surface-color: #ffffff;
            --text-color: #212529;
            --muted-color: #6c757d;
            --border-color: #dee2e6;
            --shadow-color: rgba(0, 0, 0, 0.05);
            --error-color: #dc3545;
            --success-color: #28a745;
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --radius: 8px;
            --spacing: 1rem;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            padding: calc(var(--spacing) * 2);
        }

        .container {
            max-width: 900px;
            margin: auto;
            background: var(--surface-color);
            padding: calc(var(--spacing) * 2);
            border-radius: var(--radius);
            box-shadow: 0 8px 24px var(--shadow-color);
        }

        h1 {
            text-align: center;
            color: var(--primary-color);
            margin-bottom: calc(var(--spacing) * 1.5);
        }

        .input-group {
            display: flex;
            gap: var(--spacing);
            margin-bottom: calc(var(--spacing) * 1.5);
        }

        #userAddress {
            flex-grow: 1;
            padding: var(--spacing);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            font-size: 1rem;
            transition: box-shadow 0.2s, border-color 0.2s;
        }

        #userAddress:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
        }

        #queryButton {
            padding: var(--spacing) calc(var(--spacing) * 1.5);
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--radius);
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #queryButton:hover {
            background-color: var(--primary-hover);
        }

        .tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: calc(var(--spacing) * 1.5);
        }

        .tab-link {
            padding: var(--spacing) calc(var(--spacing) * 1.5);
            cursor: pointer;
            border: none;
            border-bottom: 3px solid transparent;
            background: none;
            font-size: 1rem;
            color: var(--muted-color);
            transition: color 0.2s, border-color 0.2s;
            margin-bottom: -1px;
            /* Overlap with container border */
        }

        .tab-link:hover {
            color: var(--primary-color);
        }

        .tab-link.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
            font-weight: 600;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        #globalNetworkContainer {
            margin-top: var(--spacing);
        }

        #network-list-container {
            max-height: 600px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: var(--spacing);
        }

        .network-list-item {
            padding: calc(var(--spacing) * 0.75) var(--spacing);
            border-bottom: 1px solid #f1f3f5;
            word-break: break-all;
            /* ç¡®ä¿é•¿åœ°å€å¯ä»¥æ¢è¡Œ */
        }

        .network-list-item.has-children {
            cursor: pointer;
            font-weight: 500;
        }

        .network-list-item.has-children:hover {
            background-color: #f8f9fa;
        }

        .network-list-item.has-children::before {
            content: 'â–¶';
            /* æŠ˜å çŠ¶æ€ */
            display: inline-block;
            margin-right: 8px;
            transition: transform 0.2s ease;
            font-size: 0.8em;
        }

        .network-list-item.has-children.expanded::before {
            transform: rotate(90deg);
            /* å±•å¼€çŠ¶æ€ */
        }

        .network-list-children {
            display: none;
            /* é»˜è®¤éšè—å­èŠ‚ç‚¹ */
            padding-left: calc(var(--spacing) * 1.5);
            border-left: 2px solid var(--primary-color);
            margin-left: 4px;
        }

        .network-list-item.expanded+.network-list-children {
            display: block;
            /* ç‚¹å‡»åæ˜¾ç¤ºå­èŠ‚ç‚¹ */
        }

        .info-card {
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: calc(var(--spacing) * 1.5);
            background-color: var(--surface-color);
            box-shadow: 0 4px 12px var(--shadow-color);
        }

        .info-card h3 {
            margin-top: 0;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: var(--spacing);
            margin-bottom: var(--spacing);
            font-size: 1.2rem;
            color: var(--text-color);
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: calc(var(--spacing) * 0.75) 0;
            border-bottom: 1px solid #f1f3f5;
            flex-wrap: wrap;
        }

        .info-item:last-child {
            border-bottom: none;
        }

        .info-item dt {
            color: var(--muted-color);
        }

        .info-item dd {
            font-weight: 500;
            text-align: right;
            word-break: break-all;
        }

        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: calc(var(--spacing) * 2) auto;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .error {
            color: var(--error-color);
            font-weight: bold;
        }

        code {
            background-color: #e9ecef;
            padding: 0.2em 0.4em;
            border-radius: 4px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
            font-size: 0.9em;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        code:hover {
            background-color: #dee2e6;
        }

        .query-link {
            color: var(--primary-color);
            text-decoration: none;
            display: inline-block;
            transition: color 0.2s;
        }

        .query-link:hover {
            color: var(--primary-hover);
            text-decoration: underline;
        }

        .referral-item {
            padding: 0.5rem 0;
            border-bottom: 1px solid #f1f3f5;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .referral-item:last-child {
            border-bottom: none;
        }

        table.info-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: var(--spacing);
            box-shadow: 0 4px 12px var(--shadow-color);
            border-radius: var(--radius);
            overflow: hidden;
        }

        .info-table th,
        .info-table td {
            border: 1px solid var(--border-color);
            padding: var(--spacing);
            text-align: left;
        }

        .info-table th {
            background-color: #f8f9fa;
            font-weight: 600;
            color: var(--primary-color);
        }

        .info-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        .info-table code {
            font-size: 0.85em;
        }

        /* å¥–åŠ±åˆ†é…æ˜ç»†æ ·å¼ */
        .rewards-breakdown {
            background: var(--surface-color);
            border-radius: var(--radius);
            padding: calc(var(--spacing) * 1.5);
            margin-top: var(--spacing);
            border: 1px solid var(--border-color);
        }

        .rewards-breakdown h4 {
            margin-top: 0;
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 0.5rem;
        }

        .rewards-list {
            margin: var(--spacing) 0;
        }

        .reward-item {
            border-radius: var(--radius);
            margin: 0.5rem 0;
            padding: 1rem;
            background: rgba(248, 249, 250, 0.8);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .reward-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .reward-item>div {
            margin: 0.3rem 0;
        }

        .reward-item code {
            font-size: 0.8rem;
            background: rgba(0, 0, 0, 0.05);
        }

        .rewards-summary {
            border-radius: var(--radius);
            background: linear-gradient(135deg, rgba(0, 123, 255, 0.05), rgba(40, 167, 69, 0.05));
            border: 1px solid rgba(0, 123, 255, 0.2);
        }

        .rewards-summary h5 {
            margin-top: 0;
            color: var(--primary-color);
        }

        .rewards-summary>div {
            margin: 0.5rem 0;
            font-size: 0.95rem;
        }

        .referral-details {
            color: var(--muted-color);
            font-size: 0.85rem;
            margin-left: 0.5rem;
        }

        /* --- Mobile Responsive --- */
        @media (max-width: 768px) {
            body {
                padding: var(--spacing);
            }

            .container {
                padding: var(--spacing);
            }

            .input-group {
                flex-direction: column;
            }

            .results-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 480px) {
            .tabs {
                flex-direction: column;
                overflow-x: auto;
                white-space: nowrap;
                display: flex;
                flex-direction: row;
            }

            .tab-link {
                border-bottom-width: 2px;
                min-width: 120px;
                text-align: center;
            }

            h1 {
                font-size: 1.5rem;
            }
        }

        @media (max-width: 400px) {
            .info-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.25rem;
            }

            .info-item dd {
                text-align: left;
                width: 100%;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>FCL å…¨æ–¹ä½æŸ¥è¯¢é¢æ¿ v5.1</h1>

        <div class="input-group">
            <input type="text" id="userAddress" placeholder="è¾“å…¥é’±åŒ…åœ°å€æŸ¥è¯¢...">
            <button id="queryButton">ğŸš€ æŸ¥è¯¢</button>
        </div>

        <div class="tabs">
            <button class="tab-link active" data-tab="User">ç”¨æˆ·&å¥–åŠ±</button>
            <button class="tab-link" data-tab="PersonalNetwork">ä¸ªäººå›¢é˜Ÿ</button>
            <button class="tab-link" data-tab="GlobalNetwork">å…¨ç½‘å›¢é˜Ÿ</button>
            <button class="tab-link" data-tab="Dividend">åˆ†çº¢æŸ¥è¯¢</button>
            <button class="tab-link" data-tab="Market">å¸‚åœº&LPæ± </button>
            <button class="tab-link" data-tab="Contract">åˆçº¦å‚æ•°</button>
            <button class="tab-link" data-tab="Mining">æŒ–çŸ¿ä¿¡æ¯</button>
            <button class="tab-link" data-tab="Destroy">é”€æ¯æŸ¥è¯¢</button>
            <button class="tab-link" data-tab="Receive">æ”¶ç›Šé¢†å–</button>

        </div>

        <!-- åœ¨ User æ ‡ç­¾é¡µå†…ï¼Œæ–°å¢ä¸€ä¸ªç»“æœå®¹å™¨ç”¨äºæ˜¾ç¤ºå¼ºåˆ¶å–å¸çŠ¶æ€ -->
        <div id="User" class="tab-content active">
            <div id="userInfoResult" class="results-grid"></div>
            <!-- æ–°å¢ï¼šå¼ºåˆ¶å–å¸çŠ¶æ€æ¸²æŸ“å®¹å™¨ -->
            <div id="forcedSellStatusResult" class="results-grid"></div>
        </div>

        <div id="PersonalNetwork" class="tab-content">
            <div id="personalNetworkInfoResult" class="results-grid"></div>
        </div>

        <div id="GlobalNetwork" class="tab-content">
            <p>ä»å½“å‰è¾“å…¥æŸ¥è¯¢çš„åœ°å€å¼€å§‹å¾€ä¸‹æŸ¥è¯¢ï¼Œæœ€å¤šæ˜¾ç¤ºä¸‰å±‚ã€‚ç‚¹å‡»å¯å±•å¼€æˆ–æŠ˜å èŠ‚ç‚¹ã€‚</p>
            <div id="globalNetworkContainer">
                <div id="network-list-container"></div>
            </div>
        </div>

        <div id="Dividend" class="tab-content">
            <p>è¾“å…¥é’±åŒ…åœ°å€æŸ¥è¯¢åˆ†çº¢ä¿¡æ¯ã€‚</p>
            <div id="dividendInfoResult" class="results-grid"></div>
        </div>

        <div id="Market" class="tab-content">
            <div id="marketInfoResult" class="results-grid"></div>
        </div>

        <div id="Contract" class="tab-content">
            <div id="contractInfoResult" class="results-grid"></div>
        </div>

        <div id="Mining" class="tab-content">
            <div id="miningInfoResult" class="results-grid"></div>
        </div>

        <div id="Destroy" class="tab-content">
            <div id="destroyInfoResult" class="results-grid"></div>
        </div>

        <div id="Receive" class="tab-content">
            <div class="info-card">
                <h3>æ”¶ç›Šé¢†å–è¯´æ˜</h3>
                <p>ä»¥ä¸‹æ“ä½œå°†è§¦å‘å¯¹åº”ç±»å‹çš„æ”¶ç›Šè®¡ç®—å’Œå‘æ”¾ã€‚è¯·æ³¨æ„ï¼Œæ‰§è¡Œè½¬è´¦ä¼šäº§ç”Ÿå°‘é‡Gasè´¹ç”¨ã€‚</p>
                <table class="info-table">
                    <thead>
                        <tr>
                            <th>æ”¶ç›Šç±»å‹</th>
                            <th>è§¦å‘æ–¹å¼</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>åŠ¨æ€æ”¶ç›Š</td>
                            <td id="dynamic-reward-trigger">è½¬è´¦ <strong>0</strong> æšFCLè‡³ <strong>çŸ¿æ± åˆçº¦åœ°å€</strong> è§¦å‘</td>
                        </tr>
                        <tr>
                            <td>é™æ€æ”¶ç›Š</td>
                            <td>è½¬è´¦ <strong>0</strong> æšFCLè‡³ <strong>ä»»æ„ä¸ªäººåœ°å€</strong> è§¦å‘</td>
                        </tr>
                        <tr>
                            <td>èŠ‚ç‚¹æ”¶ç›Š</td>
                            <td id="node-reward-trigger">è½¬è´¦ <strong>0</strong> æšFCLè‡³ <strong>é»‘æ´åœ°å€</strong>
                                (<code>0x000000000000000000000000000000000000dEaD</code>) è§¦å‘</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div id="Test" class="tab-content">
            <div class="info-card">
                <h3>ğŸ§ª æœ€ç»ˆåˆ†é…æµ‹è¯•</h3>
                <div style="margin-bottom: 20px;">
                    <p style="color: #666; font-size: 14px;">è¯¥åŠŸèƒ½ç”¨äºæµ‹è¯•8000ä¸ªåœ°å€çš„æœ€ç»ˆä»£å¸åˆ†é…æœºåˆ¶ã€‚ä»…é™åˆçº¦ç®¡ç†å‘˜ä½¿ç”¨ã€‚</p>
                </div>

                <div style="display: grid; gap: 15px;">
                    <button id="generateTestUsersBtn" onclick="generateTestUsers()"
                        style="padding: 12px 20px; background: #007bff; color: white; border: none; border-radius: 6px; cursor: pointer;">
                        æ­¥éª¤1: ç”Ÿæˆ8000ä¸ªæµ‹è¯•åœ°å€
                    </button>

                    <button id="executeTestDistributionBtn" onclick="executeTestDistribution()"
                        style="padding: 12px 20px; background: #28a745; color: white; border: none; border-radius: 6px; cursor: pointer;"
                        disabled>
                        æ­¥éª¤2: æ‰§è¡Œæœ€ç»ˆåˆ†é…æµ‹è¯•
                    </button>

                    <button id="getTestResultBtn" onclick="getTestResult()"
                        style="padding: 12px 20px; background: #6c757d; color: white; border: none; border-radius: 6px; cursor: pointer;"
                        disabled>
                        æŸ¥çœ‹æµ‹è¯•ç»“æœ
                    </button>

                    <button id="resetTestBtn" onclick="resetTestState()"
                        style="padding: 12px 20px; background: #dc3545; color: white; border: none; border-radius: 6px; cursor: pointer;"
                        disabled>
                        é‡ç½®æµ‹è¯•çŠ¶æ€
                    </button>
                </div>

                <div id="testStatus"
                    style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px; display: none;">
                    <h4 style="margin-top: 0;">æµ‹è¯•çŠ¶æ€</h4>
                    <div id="testStatusContent"></div>
                </div>
            </div>

            <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
            <script>
                // --- å…¨é‡ ABI å®šä¹‰ ---
                const fullAbis = {
                    pool: [
                        "function getUserInfo(address user) view returns (address referrer, uint256 staticHashPower, uint256 dynamicHashPower, uint256 depositAmount, uint256 activationTime, uint256 staticRewards, uint256 dynamicRewards, uint256 finalTokenRewards, bool isActivated, bool isNode, uint256 directCount)",
                        "function getPendingStaticRewards(address user) view returns (uint256)",
                        "function getPendingDynamicRewards(address user) view returns (uint256)",
                        "function totalStaticHashPower() view returns (uint256)",
                        "function totalDynamicHashPower() view returns (uint256)",
                        "function totalMined() view returns (uint256)",
                        "function miningStarted() view returns (bool)",
                        "function miningStartTime() view returns (uint256)",
                        "function getCurrentDailyProduction() view returns (uint256)",
                        "function minDeposit() view returns (uint256)",
                        "function maxDeposit() view returns (uint256)",
                        "function nodeDeposit() view returns (uint256)",
                        "function TOTAL_MINABLE() view returns (uint256)",
                        "function MAX_PRODUCTION() view returns (uint256)",
                        "function END_MINING_THRESHOLD() view returns (uint256)",
                        "function BNB_TO_HASHPOWER_RATE() view returns (uint256)",
                        "function allUsers(uint256 index) view returns (address)",
                        "function getAXMPrice() view returns (uint256)",
                        "function getUserDirectCount(address user) view returns (uint256)",
                        "function generateTestUsers()",
                        "function executeTestDistribution()",
                        "function getTestDistributionResult() view returns (uint256 totalTestUsers, uint256 firstTierCount, uint256 secondTierCount, uint256 thirdTierCount, uint256 tokensDistributed, uint256 remainingTokens)",
                        "function getTestUserTokens(uint256 userIndex) view returns (address userAddress, uint256 tokenBalance, string memory tier)",
                        "function resetTestState()",
                        "event TestUsersGenerated(uint256 totalUsers)",
                        "event TestDistributionCompleted(uint256 totalUsers, uint256 finalTotalMined)",
                        "function getDirectReferrals(address user) view returns (address[] memory)",
                        "function owner() view returns (address)",
                        "event TestStateReset()"
                    ],
                    bind: [
                        "function getReferrer(address user) view returns (address)",
                        "function getSubordinates(address user) view returns (address[] memory)",
                        "function isActive(address account) view returns (bool)"
                    ],
                    token: [
                        "function balanceOf(address account) view returns (uint256)",
                        "function totalSupply() view returns (uint256)",
                        "function decimals() view returns (uint8)",
                        "function name() view returns (string)",
                        "function symbol() view returns (string)",
                        // å¼ºåˆ¶å–å¸ç›¸å…³æŸ¥è¯¢
                        "function getForcedSellStatus(address user) view returns (uint256 userTotalProduction, uint256 userTotalSold, uint256 requiredSellAmount, uint256 remainingSellAmount, bool isCompliant, uint256 nextDeadline)",
                        "function checkForcedSellRequirement(address user) view returns (bool)"
                    ],
                    pair: [
                        "function getReserves() view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast)",
                        "function token0() view returns (address)",
                        "function token1() view returns (address)"
                    ],
                    nodePool: [
                        "function isNode(address) view returns (bool)",
                        "function getNodeCount() view returns (uint256)",
                        "function getNodes() view returns (address[] memory)"
                    ]
                };
                //ä»£å¸åœ°å€
                const axmTokenAddress = "0x43e604BcB0d60e844b329Cbc26D83E76537a5334";
                // çŸ¿æ± åœ°å€
                const poolAddress = "0x14794b0e406935C437Eedd5aCA96113076E78D24";
                //LPæ± å­åœ°å€
                const pancakePairV2 = "0x8b3861f082f6bfee6b5efdca039c852f9dda1376";
                // --- åˆçº¦ä¸åœ°å€é…ç½® ---
                const config = {
                    // providerUrl: "https://bsc-mainnet.nodereal.io/v1/f224021f8b984416ae51cc25997b38a0",
                    // providerUrl: "https://api.zan.top/node/v1/bsc/testnet/3824e6f69ebf4db7a17654c6d3e80112",
                    // providerUrl: "https://api.zan.top/node/v1/bsc/testnet/f904e5129ac94446b21acedf5e37b4ca",
                    providerUrl: "https://bsc-mainnet.nodereal.io/v1/54c59ad308e141488b3ad83ea6898e70",

                    poolAddress: poolAddress,  // çŸ¿æ± åœ°å€
                    axmTokenAddress: axmTokenAddress,  // ä»£å¸åœ°å€
                    usdtAddress: '0x55d398326f99059fF775485246999027B3197955', // USDT (BSCä¸»ç½‘)
                    burnAddress: '0x000000000000000000000000000000000000dEaD', // é”€æ¯åœ°å€åˆçº¦åœ°å€
                    bindContractAddress: "0x01e36386C6bee07AEFfC57D01a84806c7219eBd8",  // ç»‘å®šåˆçº¦åœ°å€
                    nodePoolAddress: "0xe92533Da644691B0B945e5e0c586aF2223d047Ab",  // èŠ‚ç‚¹åˆçº¦åœ°å€
                    lpPairAddress: pancakePairV2,  // LPæ± å­åœ°å€
                };


                // --- åŠ¨æ€æ›´æ–°æ”¶ç›Šé¢†å–ä¿¡æ¯ ---
                document.addEventListener('DOMContentLoaded', () => {
                    const dynamicRewardEl = document.getElementById('dynamic-reward-trigger');
                    if (dynamicRewardEl) {
                        dynamicRewardEl.innerHTML = `è½¬è´¦ <strong>0</strong> æšFCLè‡³ <strong>çŸ¿æ± åˆçº¦åœ°å€</strong> (<code class="copyable">${config.poolAddress}</code>) è§¦å‘`;
                    }

                    const nodeRewardEl = document.getElementById('node-reward-trigger');
                    if (nodeRewardEl) {
                        nodeRewardEl.innerHTML = `è½¬è´¦ <strong>0</strong> æšFCLè‡³ <strong>é»‘æ´åœ°å€</strong> (<code class="copyable">${config.burnAddress}</code>) è§¦å‘`;
                    }
                });

                // --- Ethers.js å®ä¾‹ ---
                const provider = new ethers.providers.JsonRpcProvider(config.providerUrl);
                const contracts = {
                    pool: new ethers.Contract(config.poolAddress, fullAbis.pool, provider),
                    bind: new ethers.Contract(config.bindContractAddress, fullAbis.bind, provider),
                    token: new ethers.Contract(config.axmTokenAddress, fullAbis.token, provider),
                    usdt: new ethers.Contract(config.usdtAddress, fullAbis.token, provider),
                    lp: new ethers.Contract(config.lpPairAddress, fullAbis.pair, provider),
                    nodePool: new ethers.Contract(config.nodePoolAddress, fullAbis.nodePool, provider)
                };

                // --- å·¥å…·å‡½æ•° ---
                const format = (val, decimals = 18, dp = 4) => parseFloat(ethers.utils.formatUnits(val, decimals)).toFixed(dp);
                const formatDate = (ts) => ts.eq(0) ? 'å°šæœªæ¿€æ´»' : new Date(ts.toNumber() * 1000).toLocaleString('zh-CN');
                const render = (id, html) => { const element = document.getElementById(id); if (element) { element.innerHTML = html; } else { console.error(`Render target with id '${id}' not found.`); } };
                const createCard = (title, data) => {
                    let itemsHtml = Object.entries(data).map(([key, value]) => `<div class="info-item"><dt>${key}</dt><dd>${value}</dd></div>`).join('');
                    return `<div class="info-card"><h3>${title}</h3>${itemsHtml}</div>`;
                };
                const showError = (val) => `<span class="error">${val}</span>`;
                const truncateAddress = (addr) => addr ? `${addr.slice(0, 6)}...${addr.slice(-4)}` : '';
                const sleep = ms => new Promise(r => setTimeout(r, ms));
                let globalNetworkChart = null; // ç”¨äºæŒæœ‰EChartså®ä¾‹

                // --- UI æ§åˆ¶ ---
                function queryAddress(address) {
                    document.getElementById('userAddress').value = address;
                    queryAllInfo();
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }

                function openTab(evt, tabName) {
                    document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
                    document.querySelectorAll('.tab-link').forEach(tl => tl.classList.remove('active'));
                    document.getElementById(tabName).classList.add('active');
                    evt.currentTarget.classList.add('active');
                }

                // --- é¡µé¢åŠ è½½ä¸åˆå§‹åŒ– ---
                document.addEventListener('DOMContentLoaded', () => {
                    // ç»‘å®šæ ‡ç­¾é¡µç‚¹å‡»äº‹ä»¶
                    document.querySelectorAll('.tab-link').forEach(tab => {
                        tab.addEventListener('click', (e) => {
                            const tabName = e.currentTarget.getAttribute('data-tab');
                            openTab(e, tabName);
                        });
                    });

                    // é»˜è®¤æ‰“å¼€ç¬¬ä¸€ä¸ªæ ‡ç­¾é¡µ
                    if (document.querySelector('.tab-link')) {
                        document.querySelector('.tab-link').click();
                    }

                    // åŠ è½½ä¸Šæ¬¡æŸ¥è¯¢çš„åœ°å€
                    const lastAddress = localStorage.getItem('lastUserAddress');
                    if (lastAddress) {
                        document.getElementById('userAddress').value = lastAddress;
                    }

                    // ç»‘å®šæŸ¥è¯¢æŒ‰é’®å’Œå›è½¦äº‹ä»¶
                    document.getElementById('queryButton').addEventListener('click', queryAllInfo);
                    document.getElementById('userAddress').addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') queryAllInfo();
                    });

                    // äº‹ä»¶å§”æ‰˜ï¼šå¤„ç†åŠ¨æ€ç”Ÿæˆçš„æŸ¥è¯¢é“¾æ¥
                    document.addEventListener('click', (e) => {
                        if (e.target.closest('.query-link')) {
                            e.preventDefault();
                            const address = e.target.closest('.query-link').getAttribute('data-address');
                            if (address) {
                                queryAddress(address);
                            }
                        }
                    });
                });

                // --- ä¸»æŸ¥è¯¢å‡½æ•° ---
                async function queryAllInfo() {
                    const userAddress = document.getElementById('userAddress').value.trim();
                    if (!ethers.utils.isAddress(userAddress)) {
                        alert('è¯·è¾“å…¥æœ‰æ•ˆçš„é’±åŒ…åœ°å€');
                        return;
                    }
                    localStorage.setItem('lastUserAddress', userAddress);

                    // åœ¨é‡æ–°æ¸²æŸ“ä¹‹å‰ï¼Œå…ˆé”€æ¯æ—§çš„å›¾è¡¨å®ä¾‹
                    if (globalNetworkChart) {
                        globalNetworkChart.dispose();
                        globalNetworkChart = null;
                    }

                    // æ˜¾ç¤ºæ‰€æœ‰åŠ è½½åŠ¨ç”»
                    render('userInfoResult', '<div class="loader"></div>');
                    render('forcedSellStatusResult', '<div class="loader"></div>');
                    render('personalNetworkInfoResult', '<div class="loader"></div>');
                    render('dividendInfoResult', '<div class="loader"></div>æ­£åœ¨æ¨¡æ‹Ÿå…¥é‡‘1BNBçš„èµ„é‡‘æµå‘å’Œå¥–åŠ±åˆ†é…...');
                    render('marketInfoResult', '<div class="loader"></div>');
                    render('contractInfoResult', '<div class="loader"></div>');
                    render('miningInfoResult', '<div class="loader"></div>');
                    render('destroyInfoResult', '<div class="loader"></div>');

                    await Promise.all([
                        fetchUserAndRewardInfo(userAddress),
                        fetchForcedSellStatus(userAddress),
                        fetchPersonalNetworkInfo(userAddress),
                        fetchGlobalNetworkInfo(userAddress),
                        fetchDividendInfo(userAddress),
                        fetchMarketInfo(),
                        fetchContractInfo(),
                        fetchMiningInfo(),
                        fetchDestroyInfo()
                    ]).catch(err => {
                        console.error('ä¸€ä¸ªæˆ–å¤šä¸ªæŸ¥è¯¢å¤±è´¥:', err);
                    });
                }

                // --- å¼ºåˆ¶å–å¸çŠ¶æ€æŸ¥è¯¢ ---
                async function fetchForcedSellStatus(userAddress) {
                    try {
                        const [status, passed] = await Promise.all([
                            contracts.token.getForcedSellStatus(userAddress),
                            contracts.token.checkForcedSellRequirement(userAddress)
                        ]);

                        // è¿”å›ç»“æ„ï¼š
                        // [0] userTotalProduction, [1] userTotalSold, [2] requiredSellAmount,
                        // [3] remainingSellAmount, [4] isCompliant, [5] nextDeadline
                        const userTotalProduction = status[0];
                        const userTotalSold = status[1];
                        const requiredSellAmount = status[2];
                        const remainingSellAmount = status[3];
                        const isCompliant = status[4];
                        const nextDeadline = status[5];

                        const data = {
                            'åˆè§„çŠ¶æ€': (isCompliant || passed) ? 'âœ… å·²æ»¡è¶³' : 'âŒ æœªæ»¡è¶³',
                            'å·²å–æ•°é‡': `${format(userTotalSold)} FCL`,
                            'éœ€å–æ•°é‡': `${format(requiredSellAmount)} FCL`,
                            'å‰©ä½™éœ€å–': `${format(remainingSellAmount)} FCL`,
                            'ä¸‹ä¸ªæˆªæ­¢æ—¶é—´': nextDeadline.eq(0) ? 'æœªæ¿€æ´»æˆ–æ— å‘¨æœŸ' : new Date(nextDeadline.toNumber() * 1000).toLocaleString('zh-CN'),
                            'æ€»äº§å‡º(ç´¯è®¡)': `${format(userTotalProduction)} FCL`
                        };

                        render('forcedSellStatusResult', createCard('â›” å¼ºåˆ¶å–å¸çŠ¶æ€', data));
                    } catch (e) {
                        console.error('æŸ¥è¯¢å¼ºåˆ¶å–å¸çŠ¶æ€å¤±è´¥:', e);
                        render('forcedSellStatusResult', showError('æŸ¥è¯¢å¼ºåˆ¶å–å¸çŠ¶æ€å¤±è´¥'));
                    }
                }

                // --- æ•°æ®è·å–æ¨¡å— ---
                async function fetchUserAndRewardInfo(userAddress) {
                    let userInfoData = {}, rewardData = {};
                    try {
                        const [
                            userInfo, axmBalance, usdtBalance, usdtDecimals,
                            miningStarted, miningStartTime, isNodeStatus
                        ] = await Promise.all([
                            contracts.pool.getUserInfo(userAddress),
                            contracts.token.balanceOf(userAddress),
                            contracts.usdt.balanceOf(userAddress),
                            contracts.usdt.decimals(),
                            contracts.pool.miningStarted(),
                            contracts.pool.miningStartTime(),
                            contracts.nodePool.isNode(userAddress)
                        ]);

                        // è°ƒè¯•ä¿¡æ¯
                        console.log('UserInfoç»“æ„:', userInfo);
                        console.log('UserInfoé•¿åº¦:', userInfo.length);

                        // è®¡ç®—åˆ†é…æ¬¡æ•°
                        let allocationCountText = 'ä¸é€‚ç”¨';
                        const activationTimestamp = userInfo[4].toNumber();
                        const now = Math.floor(Date.now() / 1000);
                        const startTime = miningStartTime.toNumber();
                        const periodDuration = 24 * 60 * 60; // 24å°æ—¶

                        if (activationTimestamp > 0) {
                            // è‹¥æŒ–çŸ¿å°šæœªå¼€å§‹ï¼ˆæ— å¼€å§‹æ—¶é—´æˆ–å½“å‰æ—¶é—´æ—©äºå¼€å§‹æ—¶é—´ï¼‰ï¼Œæ˜¾ç¤ºâ€œæŒ–çŸ¿æœªå¼€å§‹â€
                            if (!miningStarted || miningStartTime.eq(0) || now < startTime) {
                                allocationCountText = 'æŒ–çŸ¿æœªå¼€å§‹';
                            } else {
                                // ä»ç”¨æˆ·æ¿€æ´»æ—¶é—´ä¸æŒ–çŸ¿å¼€å§‹æ—¶é—´çš„è¾ƒå¤§å€¼å¼€å§‹è®¡ç®—
                                const effectiveActivation = Math.max(activationTimestamp, startTime);
                                const elapsed = now - effectiveActivation;
                                const count = Math.floor(elapsed / periodDuration);
                                allocationCountText = `${Math.max(0, count)} æ¬¡`;
                            }
                        }

                        // åˆ¤æ–­ç”¨æˆ·æ¿€æ´»çŠ¶æ€ï¼šæœ‰ç®—åŠ›å°±è¯´æ˜å·²æ¿€æ´»
                        const isActivated = userInfo[1].gt(0) || userInfo[2].gt(0); // staticHashPower > 0 æˆ– dynamicHashPower > 0

                        userInfoData = {
                            'ç”¨æˆ·çŠ¶æ€': isActivated ? 'âœ… å·²æ¿€æ´»' : 'âŒ æœªæ¿€æ´»',
                            'èŠ‚ç‚¹çŠ¶æ€': isNodeStatus ? 'ğŸ’  æ˜¯èŠ‚ç‚¹' : 'å¦',
                            'æ¿€æ´»æ—¶é—´': formatDate(userInfo[4]),
                            'åˆ†é…æ¬¡æ•°': allocationCountText,
                            'FCL ä½™é¢': `<b>${format(axmBalance)} FCL</b>`,
                            'USDT ä½™é¢': `<b>${format(usdtBalance, usdtDecimals)} USDT</b>`,
                        };
                        rewardData = {
                            'å…¥é‡‘æ€»é¢': `${format(userInfo[3])} BNB`,
                            'é™æ€ç®—åŠ›': format(userInfo[1], 18),
                            'åŠ¨æ€ç®—åŠ›': format(userInfo[2], 18),
                            'å·²é¢†é™æ€æ”¶ç›Š': `${format(userInfo[5], 18)} FCL`,
                            'å·²é¢†åŠ¨æ€æ”¶ç›Š': `${format(userInfo[6], 18)} FCL`,
                            'ç›´æ¨æ•°é‡': `${userInfo[10].toString()} äºº`
                        };

                        // ç‹¬ç«‹æŸ¥è¯¢å¾…é¢†å¥–åŠ±ï¼Œè¿›è¡Œé”™è¯¯éš”ç¦»
                        try {
                            const [pendingStatic, pendingDynamic] = await Promise.all([
                                contracts.pool.getPendingStaticRewards(userAddress),
                                contracts.pool.getPendingDynamicRewards(userAddress)
                            ]);
                            rewardData['å¯é¢†é™æ€å¥–åŠ±'] = `${format(pendingStatic)} FCL`;
                            rewardData['å¯é¢†åŠ¨æ€å¥–åŠ±'] = `${format(pendingDynamic)} FCL`;
                        } catch (e) {
                            console.error('Could not get pending rewards:', e.message);
                            rewardData['å¯é¢†é™æ€å¥–åŠ±'] = '0.0000 FCL';
                            rewardData['å¯é¢†åŠ¨æ€å¥–åŠ±'] = '0.0000 FCL';
                        }

                        // è®¡ç®—é¢„è®¡ä¸‹æ¬¡åˆ†çº¢å¥–åŠ±
                        try {
                            const [
                                totalStaticHashPower, totalDynamicHashPower,
                                currentDailyProduction
                            ] = await Promise.all([
                                contracts.pool.totalStaticHashPower(),
                                contracts.pool.totalDynamicHashPower(),
                                contracts.pool.getCurrentDailyProduction()
                            ]);

                            const userStaticHashPower = userInfo[1]; // ç”¨æˆ·é™æ€ç®—åŠ›
                            const userDynamicHashPower = userInfo[2]; // ç”¨æˆ·åŠ¨æ€ç®—åŠ›

                            let nextStaticReward = 0;
                            let nextDynamicReward = 0;

                            if (miningStarted && !currentDailyProduction.eq(0)) {
                                // é™æ€å¥–åŠ±ï¼š67%çš„å‘¨æœŸäº§é‡ * (ç”¨æˆ·é™æ€ç®—åŠ› / å…¨ç½‘é™æ€ç®—åŠ›)
                                const staticPortion = currentDailyProduction.mul(667).div(1000);
                                if (totalStaticHashPower.gt(0) && userStaticHashPower.gt(0)) {
                                    nextStaticReward = parseFloat(format(
                                        userStaticHashPower.mul(staticPortion).div(totalStaticHashPower)
                                    ));
                                }

                                // åŠ¨æ€å¥–åŠ±ï¼š33%çš„å‘¨æœŸäº§é‡ * (ç”¨æˆ·åŠ¨æ€ç®—åŠ› / å…¨ç½‘åŠ¨æ€ç®—åŠ›)
                                const dynamicPortion = currentDailyProduction.mul(333).div(1000);
                                if (totalDynamicHashPower.gt(0) && userDynamicHashPower.gt(0)) {
                                    nextDynamicReward = parseFloat(format(
                                        userDynamicHashPower.mul(dynamicPortion).div(totalDynamicHashPower)
                                    ));
                                }
                            }

                            rewardData['é¢„è®¡ä¸‹æ¬¡é™æ€åˆ†çº¢'] = `${nextStaticReward.toFixed(4)} FCL`;
                            rewardData['é¢„è®¡ä¸‹æ¬¡åŠ¨æ€åˆ†çº¢'] = `${nextDynamicReward.toFixed(4)} FCL`;
                            rewardData['é¢„è®¡æ€»åˆ†çº¢'] = `${(nextStaticReward + nextDynamicReward).toFixed(4)} FCL`;

                        } catch (e) {
                            console.error('Could not calculate next rewards:', e.message);
                            rewardData['é¢„è®¡é™æ€åˆ†çº¢'] = '0.0000 FCL';
                            rewardData['é¢„è®¡åŠ¨æ€åˆ†çº¢'] = '0.0000 FCL';
                            rewardData['é¢„è®¡æ€»åˆ†çº¢'] = '0.0000 FCL';
                        }

                    } catch (e) {
                        console.error('Error fetching user/reward info:', e);
                        userInfoData['é”™è¯¯'] = showError('æ— æ³•è·å–ç”¨æˆ·åŸºæœ¬ä¿¡æ¯');
                        rewardData['é”™è¯¯'] = showError('æ— æ³•è·å–æ”¶ç›Šä¿¡æ¯');
                    }
                    render('userInfoResult', createCard('ğŸ‘¤ ç”¨æˆ·ä¿¡æ¯', userInfoData) + createCard('ğŸ’° ç®—åŠ›ä¸æ”¶ç›Š', rewardData));
                }

                async function fetchPersonalNetworkInfo(userAddress) {
                    let networkData = {}, teamData = {};
                    try {
                        const [referrer, userInfo, isNodeStatus] = await Promise.all([
                            contracts.bind.getReferrer(userAddress),
                            contracts.pool.getUserInfo(userAddress),
                            contracts.nodePool.isNode(userAddress)
                        ]);

                        if (referrer === ethers.constants.AddressZero) {
                            networkData['æ¨èäºº'] = 'æ— ';
                        } else {
                            networkData['æ¨èäºº'] = `<a href="#" class="query-link" data-address="${referrer}" title="ç‚¹å‡»æŸ¥è¯¢è¯¥åœ°å€"><code>${referrer}</code></a>`;
                        }
                        // ç‹¬ç«‹æŸ¥è¯¢ç›´æ¨åˆ—è¡¨
                        let directReferralsCount = 0;
                        try {
                            const referrals = await contracts.bind.getSubordinates(userAddress);
                            directReferralsCount = referrals.length;

                            if (referrals.length > 0) {
                                // æ‰¹é‡æŸ¥è¯¢ç›´æ¨ç”¨æˆ·çš„è¯¦ç»†ä¿¡æ¯
                                const userInfoPromises = referrals.map(addr =>
                                    contracts.pool.getUserInfo(addr).catch(e => {
                                        console.warn(`Failed to get info for ${addr}:`, e.message);
                                        return null;
                                    })
                                );

                                const userInfos = await Promise.all(userInfoPromises);

                                let referralHtml = referrals.map((addr, index) => {
                                    const userInfo = userInfos[index];
                                    let detailInfo = '';

                                    if (userInfo && userInfo.length >= 11) {
                                        const depositAmount = format(userInfo[3]); // depositAmount
                                        // æ ¹æ® 1BNB = 1000ç®—åŠ› è®¡ç®—ç®—åŠ›
                                        const hashPower = parseFloat(depositAmount) * 1000;
                                        detailInfo = `<span class="referral-details">æŠ•å…¥: ${depositAmount} BNB | ç®—åŠ›: ${hashPower.toFixed(4)}</span>`;
                                    } else {
                                        detailInfo = '<span class="referral-details">æŠ•å…¥: æŸ¥è¯¢å¤±è´¥ | ç®—åŠ›: æŸ¥è¯¢å¤±è´¥</span>';
                                    }

                                    return `<div class="referral-item"><a href="#" class="query-link" data-address="${addr}" title="ç‚¹å‡»æŸ¥è¯¢è¯¥åœ°å€"><code>${addr.substring(0, 8)}...${addr.substring(34)}</code></a><br>${detailInfo}</div>`;
                                }).join('');

                                networkData['ç›´æ¨åˆ—è¡¨'] = referralHtml;
                            } else {
                                networkData['ç›´æ¨åˆ—è¡¨'] = 'æ— ';
                            }
                        } catch (e) {
                            networkData['ç›´æ¨åˆ—è¡¨'] = showError('æŸ¥è¯¢å¤±è´¥');
                            console.error('Could not get direct referrals:', e.message);
                        }

                        networkData['ç›´æ¨æ•°é‡'] = `${directReferralsCount} äºº`;

                        // å›¢é˜Ÿä¿¡æ¯åŸºäºç”¨æˆ·ä¿¡æ¯è®¡ç®—
                        try {
                            const referrals = await contracts.bind.getSubordinates(userAddress);
                            teamData['å›¢é˜Ÿæ€»äººæ•°'] = `${referrals.length} äºº`;

                            // è®¡ç®—å›¢é˜Ÿæ€»ä¸šç»© - éå†æ‰€æœ‰ç›´æ¨ç”¨æˆ·çš„å…¥é‡‘æ€»é¢
                            let totalTeamDeposit = ethers.BigNumber.from(0);
                            let activeTeamMembers = 0;

                            if (referrals.length > 0) {
                                // æ‰¹é‡æŸ¥è¯¢ç›´æ¨ç”¨æˆ·ä¿¡æ¯
                                const userInfoPromises = referrals.map(addr =>
                                    contracts.pool.getUserInfo(addr).catch(e => {
                                        console.warn(`Failed to get info for ${addr}:`, e.message);
                                        return null;
                                    })
                                );

                                const userInfos = await Promise.all(userInfoPromises);

                                for (let i = 0; i < userInfos.length; i++) {
                                    const userInfo = userInfos[i];
                                    if (userInfo && userInfo.length >= 11) {
                                        // userInfo[3] æ˜¯ depositAmount
                                        totalTeamDeposit = totalTeamDeposit.add(userInfo[3]);
                                        // åˆ¤æ–­æ¿€æ´»çŠ¶æ€ï¼šæœ‰ç®—åŠ›å°±è¯´æ˜å·²æ¿€æ´»
                                        const isActivated = userInfo[1].gt(0) || userInfo[2].gt(0);
                                        if (isActivated) {
                                            activeTeamMembers++;
                                        }
                                    }
                                }
                            }

                            teamData['å›¢é˜Ÿæ€»ä¸šç»©'] = `${format(totalTeamDeposit)} BNB`;
                            teamData['æ´»è·ƒæˆå‘˜'] = `${activeTeamMembers} äºº`;
                            teamData['å¹³å‡ä¸šç»©'] = referrals.length > 0 ?
                                `${format(totalTeamDeposit.div(referrals.length))} BNB/äºº` : '0 BNB/äºº';

                        } catch (e) {
                            console.error('Could not get team info:', e.message);
                            teamData['å›¢é˜Ÿæ€»ä¸šç»©'] = '0.0000 BNB';
                            teamData['å›¢é˜Ÿæ€»äººæ•°'] = '0 äºº';
                            teamData['æ´»è·ƒæˆå‘˜'] = '0 äºº';
                            teamData['å¹³å‡ä¸šç»©'] = '0 BNB/äºº';
                        }

                    } catch (e) {
                        console.error('Error fetching network info:', e);
                        networkData['é”™è¯¯'] = showError('æ— æ³•è·å–ç½‘ç»œä¿¡æ¯');
                        teamData['é”™è¯¯'] = showError('æ— æ³•è·å–å›¢é˜Ÿä¿¡æ¯');
                    }
                    render('personalNetworkInfoResult', createCard('ğŸŒ æ¨èç½‘ç»œ', networkData) + createCard('ğŸ‘¥ å›¢é˜Ÿæ•°æ®', teamData));
                }

                // --- å…¨ç½‘å›¢é˜Ÿç½‘ç»œæŸ¥è¯¢ ---
                async function fetchGlobalNetworkInfo(startAddress) {
                    const listContainer = document.getElementById('network-list-container');

                    try {
                        listContainer.innerHTML = '<div class="loader"></div>';

                        if (!startAddress || !ethers.utils.isAddress(startAddress)) {
                            listContainer.innerHTML = showError('æ— æ•ˆçš„èµ·å§‹æŸ¥è¯¢åœ°å€ã€‚');
                            return;
                        }

                        const nodes = [];
                        const links = [];
                        const addressSet = new Set();

                        async function fetchLayer(address, depth) {
                            if (depth > 3 || addressSet.has(address) || address === ethers.constants.AddressZero) {
                                return;
                            }
                            addressSet.add(address);

                            const userInfo = await contracts.pool.getUserInfo(address).catch(() => null);
                            const investment = userInfo ? parseFloat(format(userInfo[3])) : 0;

                            nodes.push({
                                id: address,
                                value: investment,
                            });

                            const referrals = await contracts.bind.getSubordinates(address).catch(() => []);
                            for (const referral of referrals) {
                                if (referral !== ethers.constants.AddressZero) {
                                    links.push({ source: address, target: referral });
                                    await sleep(100);
                                    await fetchLayer(referral, depth + 1);
                                }
                            }
                        }

                        await fetchLayer(startAddress, 0);

                        const nodeMap = new Map(nodes.map(node => [node.id, { ...node, children: [] }]));
                        links.forEach(link => {
                            const parent = nodeMap.get(link.source);
                            const child = nodeMap.get(link.target);
                            if (parent && child) {
                                parent.children.push(child);
                            }
                        });
                        const treeData = nodeMap.get(startAddress);

                        renderNetworkList(treeData, listContainer);

                    } catch (e) {
                        console.error('è·å–å…¨ç½‘å›¢é˜Ÿç½‘ç»œä¿¡æ¯å¤±è´¥:', e);
                        listContainer.innerHTML = showError(`è·å–å…¨ç½‘å›¢é˜Ÿç½‘ç»œä¿¡æ¯å¤±è´¥: ${e.message}`);
                    }
                }

                function renderNetworkList(rootNode, container) {
                    container.innerHTML = '';
                    const fragment = document.createDocumentFragment();

                    function buildList(node) {
                        if (!node) return null;

                        const item = document.createElement('div');
                        item.className = 'network-list-item';
                        item.innerHTML = `<code>${node.id}</code> (æŠ•å…¥: ${node.value.toFixed(4)} BNB)`;

                        const hasChildren = node.children && node.children.length > 0;
                        if (hasChildren) {
                            item.classList.add('has-children');

                            const childrenContainer = document.createElement('div');
                            childrenContainer.className = 'network-list-children';

                            node.children.forEach(child => {
                                const childElement = buildList(child);
                                if (childElement) {
                                    childrenContainer.appendChild(childElement);
                                }
                            });

                            item.addEventListener('click', (e) => {
                                e.stopPropagation();
                                item.classList.toggle('expanded');
                            });

                            const wrapper = document.createElement('div');
                            wrapper.appendChild(item);
                            wrapper.appendChild(childrenContainer);
                            return wrapper;
                        }

                        return item;
                    }

                    const rootElement = buildList(rootNode);
                    if (rootElement) {
                        fragment.appendChild(rootElement);
                    }
                    container.appendChild(fragment);
                }

                // --- åˆ†çº¢ä¿¡æ¯æŸ¥è¯¢ - æ¨¡æ‹Ÿå…¥é‡‘1BNBçš„èµ„é‡‘æµå‘å’Œå¥–åŠ±åˆ†é… ---
                async function fetchDividendInfo(userAddress) {
                    render('dividendInfoResult', '<div class="loader"></div>æ­£åœ¨æ¨¡æ‹Ÿå…¥é‡‘1BNBçš„èµ„é‡‘æµå‘å’Œå¥–åŠ±åˆ†é…...');

                    try {
                        const depositAmount = ethers.utils.parseEther("1.0"); // 1 BNB
                        const simulationData = await simulateDepositRewards(userAddress, depositAmount);

                        const flowData = {
                            'æ¨¡æ‹Ÿå…¥é‡‘': `${format(depositAmount)} BNB`,
                            'ç”¨æˆ·åœ°å€': `<code>${truncateAddress(userAddress)}</code>`,
                            'æ—¶é—´': new Date().toLocaleString('zh-CN')
                        };

                        let html = '';

                        // èµ„é‡‘è½¬æ¢è¿‡ç¨‹
                        html += '<div class="conversion-process" style="margin: 15px 0; padding: 15px; background: rgba(40, 167, 69, 0.1); border-radius: 8px; border-left: 4px solid #28a745;">';
                        html += '<h4>ğŸ’± èµ„é‡‘è½¬æ¢è¿‡ç¨‹</h4>';
                        html += `<div style="margin: 10px 0;">`;
                        html += `<div>1. å…¨éƒ¨å…¥é‡‘1 BNBé€šè¿‡PancakeSwap V3è½¬æ¢ä¸ºUSDT</div>`;
                        html += `<div>2. å‡è®¾å½“å‰BNBä»·æ ¼çº¦ ${simulationData.bnbPrice} USDT</div>`;
                        html += `<div>3. è½¬æ¢åè·å¾—çº¦ <strong>${simulationData.totalUSDT} USDT</strong></div>`;
                        html += `</div></div>`;

                        // èµ„é‡‘åˆ†é…æµå‘
                        html += '<div class="fund-distribution" style="margin: 15px 0;">';
                        html += '<h4>ğŸ’° èµ„é‡‘åˆ†é…æµå‘</h4>';

                        // ç³»ç»Ÿåˆ†é…
                        html += '<div class="system-allocations" style="margin: 10px 0; padding: 10px; background: rgba(108, 117, 125, 0.1); border-radius: 5px;">';
                        html += '<h5>ğŸ›ï¸ ç³»ç»Ÿåˆ†é… (å›ºå®šæ¯”ä¾‹)</h5>';
                        simulationData.systemAllocations.forEach(allocation => {
                            html += `
                        <div style="margin: 5px 0; padding: 8px; background: white; border-radius: 3px; border-left: 3px solid ${getRewardColor(allocation.type)};">
                            <div><strong>${allocation.type}</strong></div>
                            <div>åˆ†é…é‡‘é¢: <span style="color: #007bff; font-weight: bold;">${allocation.amount} USDT</span> (${allocation.percentage}%)</div>
                            <div>æ¥æ”¶åœ°å€: <code>${truncateAddress(allocation.recipient)}</code></div>
                            ${allocation.description ? `<div style="color: #6c757d; font-size: 0.9em;">${allocation.description}</div>` : ''}
                        </div>
                    `;
                        });
                        html += '</div>';

                        // æ¨èå¥–åŠ±åˆ†é…
                        if (simulationData.referralRewards && simulationData.referralRewards.length > 0) {
                            html += '<div class="referral-rewards" style="margin: 10px 0; padding: 10px; background: rgba(40, 167, 69, 0.1); border-radius: 5px;">';
                            html += '<h5>ğŸ¯ æ¨èå¥–åŠ±åˆ†é… (20%åˆ†å±‚åˆ†é…)</h5>';

                            simulationData.referralRewards.forEach((reward, index) => {
                                html += `
                            <div style="margin: 5px 0; padding: 8px; background: white; border-radius: 3px; border-left: 3px solid ${getRewardColor(reward.type)};">
                                <div><strong>${reward.type}</strong></div>
                                <div>æ¥æ”¶åœ°å€: <code>${truncateAddress(reward.recipient)}</code></div>
                                <div>USDTå¥–åŠ±: <span style="color: #28a745; font-weight: bold;">${reward.usdtAmount} USDT</span> (${reward.percentage}%)</div>
                                <div>ç®—åŠ›å¥–åŠ±: <span style="color: #17a2b8; font-weight: bold;">+${reward.hashPowerAmount}</span> ç®—åŠ› (${reward.hashPowerPercentage}%)</div>
                                ${reward.level ? `<div>æ¨èå±‚çº§: ç¬¬${reward.level}å±‚</div>` : ''}
                                ${reward.condition ? `<div style="color: #6c757d; font-size: 0.9em;">æ¡ä»¶: ${reward.condition}</div>` : ''}
                            </div>
                        `;
                            });
                            html += '</div>';
                        } else {
                            html += '<div class="no-referrals" style="margin: 10px 0; padding: 10px; background: rgba(255, 193, 7, 0.1); border-radius: 5px; color: #856404;">';
                            html += '<h5>âš ï¸ æ¨èå¥–åŠ±åˆ†é…</h5>';
                            html += '<div>è¯¥ç”¨æˆ·æš‚æ— æ¨èå…³ç³»ï¼Œ20%æ¨èå¥–åŠ±èµ„é‡‘å°†ï¼š</div>';
                            html += '<div>â€¢ ç”¨äºåç»­ç”¨æˆ·çš„æ¨èå¥–åŠ±æ± </div>';
                            html += '<div>â€¢ æˆ–ä½œä¸ºç³»ç»Ÿå¤‡ç”¨èµ„é‡‘</div>';
                            html += '</div>';
                        }

                        // è–„é¥¼ä¹°å¸æ³¨å…¥LPæœºåˆ¶
                        html += '<div class="pancake-mechanism" style="margin: 10px 0; padding: 10px; background: rgba(253, 126, 20, 0.1); border-radius: 5px;">';
                        html += '<h5>ğŸ¥ è–„é¥¼ä¹°å¸æ³¨å…¥LPæœºåˆ¶ (1.5%)</h5>';
                        html += `<div>æœºåˆ¶è¯´æ˜: ${simulationData.pancakeMechanism.amount} USDTç”¨äºè´­ä¹°FCLä»£å¸å¹¶æ³¨å…¥æµåŠ¨æ€§æ± </div>`;
                        html += '<div>æ‰§è¡Œæ­¥éª¤:</div>';
                        html += '<div style="margin-left: 20px;">1. ä½¿ç”¨1.5% USDTåœ¨è–„é¥¼V2è´­ä¹°FCLä»£å¸</div>';
                        html += '<div style="margin-left: 20px;">2. å°†è´­ä¹°çš„FCLä¸ç­‰é‡USDTç»„æˆLPæ³¨å…¥æµåŠ¨æ€§æ± </div>';
                        html += '<div style="margin-left: 20px;">3. å¢åŠ FCL/USDTæ± å­æ·±åº¦ï¼Œå‡å°‘ä»·æ ¼æ»‘ç‚¹</div>';
                        html += '<div style="margin-left: 20px;">4. ä¸ºç”¨æˆ·æä¾›æ›´å¥½çš„äº¤æ˜“ä½“éªŒ</div>';
                        html += '</div>';

                        html += '</div>';

                        // ç»Ÿè®¡æ±‡æ€»
                        html += '<div class="summary" style="margin: 15px 0; padding: 15px; background: rgba(23, 162, 184, 0.1); border-radius: 8px; border-left: 4px solid #17a2b8;">';
                        html += '<h4>ğŸ“Š åˆ†é…ç»Ÿè®¡æ±‡æ€»</h4>';
                        html += `<div class="summary-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">`;
                        html += `<div><strong>æ€»USDT:</strong> ${simulationData.totalUSDT} USDT</div>`;
                        html += `<div><strong>æ¨èå¥–åŠ±:</strong> ${simulationData.summary.totalReferralRewards} USDT (${simulationData.summary.referralPercentage}%)</div>`;
                        html += `<div><strong>ç³»ç»Ÿè´¹ç”¨:</strong> ${simulationData.summary.totalSystemFees} USDT (${simulationData.summary.systemPercentage}%)</div>`;
                        html += `<div><strong>å‰©ä½™èµ„é‡‘:</strong> ${simulationData.summary.remainingFunds} USDT (${simulationData.summary.remainingPercentage}%)</div>`;
                        html += `<div><strong>ç”¨æˆ·ç®—åŠ›å¢åŠ :</strong> +${simulationData.summary.userHashPowerGain}</div>`;
                        html += `<div><strong>æ¨èç®—åŠ›åˆ†é…:</strong> +${simulationData.summary.totalReferralHashPower}</div>`;
                        html += `</div>`;
                        html += '</div>';

                        render('dividendInfoResult',
                            createCard('ğŸ’° å…¥é‡‘åˆ†é…æ¨¡æ‹Ÿ', flowData) +
                            '<div style="margin-top: 15px;">' + html + '</div>'
                        );

                    } catch (e) {
                        console.error('Error simulating dividend info:', e);
                        render('dividendInfoResult', showError('æ¨¡æ‹Ÿåˆ†çº¢ä¿¡æ¯æ—¶å‡ºé”™: ' + e.message));
                    }
                }

                // å®Œæ•´æ¨¡æ‹Ÿå…¥é‡‘åˆ†é…é€»è¾‘ - ä¸¥æ ¼æŒ‰ç…§åˆçº¦è§„åˆ™
                async function simulateDepositRewards(userAddress, depositAmount) {
                    const depositBNB = parseFloat(format(depositAmount));

                    // æ¨¡æ‹ŸBNBè½¬USDT (å‡è®¾å½“å‰ä»·æ ¼600 USDT)
                    const bnbPrice = 600; // å¯ä»¥ä»å®é™…åˆçº¦è·å–
                    const totalUSDT = (depositBNB * bnbPrice).toFixed(2);
                    const totalUSDTAmount = parseFloat(totalUSDT);

                    const result = {
                        bnbPrice: bnbPrice,
                        totalUSDT: totalUSDT,
                        systemAllocations: [],
                        referralRewards: [],
                        pancakeMechanism: {},
                        summary: {}
                    };

                    // ç³»ç»Ÿå›ºå®šåˆ†é…
                    const systemAllocations = [
                        { type: 'æŠ€æœ¯å›¢é˜Ÿ', percentage: 2, recipient: config.techWallet, description: 'ç”¨äºæŠ€æœ¯å¼€å‘å’Œç»´æŠ¤' },
                        { type: 'è¿è¥å›¢é˜Ÿ', percentage: 8, recipient: config.operationWallet, description: 'ç”¨äºé¡¹ç›®è¿è¥å’Œæ¨å¹¿' },
                        { type: 'èŠ‚ç‚¹åˆ†çº¢æ± ', percentage: 5, recipient: config.nodePoolAddress, description: 'åˆ†é…ç»™æ¿€æ´»èŠ‚ç‚¹çš„å¥–åŠ±æ± ' },
                        { type: 'å¤‡ç”¨é‡‘', percentage: 5, recipient: config.poolAddress, description: 'ä»·æ ¼è¾¾åˆ°10Uæ—¶ç”¨äºå›è´­é”€æ¯' },
                        { type: 'è–„é¥¼ä¹°å¸æ³¨å…¥LP', percentage: 1.5, recipient: 'PancakeSwap V2', description: 'è‡ªåŠ¨ä¹°å¸å¹¶å¢åŠ æµåŠ¨æ€§' }
                    ];

                    systemAllocations.forEach(allocation => {
                        const amount = (totalUSDTAmount * allocation.percentage / 100).toFixed(4);
                        result.systemAllocations.push({
                            ...allocation,
                            amount: amount
                        });
                    });

                    // è–„é¥¼æœºåˆ¶è¯¦æƒ…
                    result.pancakeMechanism = {
                        amount: (totalUSDTAmount * 1.5 / 100).toFixed(4),
                        description: '1.5% USDTç”¨äºåœ¨è–„é¥¼V2è´­ä¹°FCLå¹¶æ³¨å…¥æµåŠ¨æ€§æ± '
                    };

                    // æ¨èå¥–åŠ±åˆ†é… (20%æ€»é¢)
                    const referralTotalAmount = totalUSDTAmount * 0.2;
                    const userHashPower = depositBNB * 1000; // 1 BNB = 1000ç®—åŠ›

                    try {
                        const referrer = await contracts.bind.getReferrer(userAddress);

                        if (referrer && referrer !== '0x0000000000000000000000000000000000000000') {
                            // ç›´æ¨å¥–åŠ± (10%)
                            const directReward = referralTotalAmount * 0.5; // 20%ä¸­çš„50%
                            const directHashPower = userHashPower * 0.1; // 10%ç®—åŠ›

                            result.referralRewards.push({
                                type: 'ç›´æ¨å¥–åŠ±',
                                recipient: referrer,
                                usdtAmount: directReward.toFixed(4),
                                percentage: '10',
                                hashPowerAmount: directHashPower.toFixed(0),
                                hashPowerPercentage: '10',
                                level: 1
                            });

                            // å¤šä»£å¥–åŠ±åˆ†é… (å‰©ä½™10%)
                            const multiGenAmount = referralTotalAmount * 0.5;
                            let currentReferrer = referrer;

                            // è·å–ç›´æ¨æ•°é‡æ¥ç¡®å®šå¤šä»£å¥–åŠ±
                            try {
                                const directCount = await contracts.pool.getUserDirectCount(referrer);
                                const directCountNum = directCount.toNumber();

                                // 2ä»£å¥–åŠ± (éœ€è¦2ä¸ªç›´æ¨)
                                if (directCountNum >= 2) {
                                    const reward2 = multiGenAmount * 0.2; // 2%
                                    const hashPower2 = userHashPower * 0.25; // 25%ç®—åŠ›

                                    result.referralRewards.push({
                                        type: '2ä»£å¥–åŠ±',
                                        recipient: currentReferrer,
                                        usdtAmount: reward2.toFixed(4),
                                        percentage: '2',
                                        hashPowerAmount: hashPower2.toFixed(0),
                                        hashPowerPercentage: '25',
                                        level: 2,
                                        condition: 'éœ€è¦2ä¸ªç›´æ¨'
                                    });

                                    // ç»§ç»­å‘ä¸ŠæŸ¥æ‰¾3ä»£
                                    const upperReferrer = await contracts.bind.getReferrer(currentReferrer);
                                    if (upperReferrer && upperReferrer !== '0x0000000000000000000000000000000000000000') {
                                        const upperDirectCount = await contracts.pool.getUserDirectCount(upperReferrer);

                                        // 3ä»£å¥–åŠ± (éœ€è¦3ä¸ªç›´æ¨)
                                        if (upperDirectCount.toNumber() >= 3) {
                                            const reward3 = multiGenAmount * 0.08; // 0.8%
                                            const hashPower3 = userHashPower * 0.1; // 10%ç®—åŠ›

                                            result.referralRewards.push({
                                                type: '3ä»£å¥–åŠ±',
                                                recipient: upperReferrer,
                                                usdtAmount: reward3.toFixed(4),
                                                percentage: '0.8',
                                                hashPowerAmount: hashPower3.toFixed(0),
                                                hashPowerPercentage: '10',
                                                level: 3,
                                                condition: 'éœ€è¦3ä¸ªç›´æ¨'
                                            });

                                            // 4-15ä»£å¥–åŠ± (æ¯ä»£éœ€è¦å¯¹åº”ç›´æ¨æ•°ï¼Œæ¯ä»£0.6%æ”¶ç›Šï¼Œ6.6%ç®—åŠ›)
                                            let currentLevel = 4;
                                            let currentAddr = upperReferrer;

                                            while (currentLevel <= 15) {
                                                try {
                                                    const nextReferrer = await contracts.bind.getReferrer(currentAddr);
                                                    if (!nextReferrer || nextReferrer === '0x0000000000000000000000000000000000000000') break;

                                                    const nextDirectCount = await contracts.pool.getUserDirectCount(nextReferrer);
                                                    if (nextDirectCount.toNumber() >= currentLevel) {
                                                        const rewardN = multiGenAmount * 0.06; // 0.6%
                                                        const hashPowerN = userHashPower * 0.066; // 6.6%ç®—åŠ›

                                                        result.referralRewards.push({
                                                            type: `${currentLevel}ä»£å¥–åŠ±`,
                                                            recipient: nextReferrer,
                                                            usdtAmount: rewardN.toFixed(4),
                                                            percentage: '0.6',
                                                            hashPowerAmount: hashPowerN.toFixed(0),
                                                            hashPowerPercentage: '6.6',
                                                            level: currentLevel,
                                                            condition: `éœ€è¦${currentLevel}ä¸ªç›´æ¨`
                                                        });
                                                    }

                                                    currentAddr = nextReferrer;
                                                    currentLevel++;
                                                } catch (e) {
                                                    console.warn(`è·å–ç¬¬${currentLevel}å±‚æ¨èäººå¤±è´¥:`, e.message);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            } catch (e) {
                                console.warn('è·å–ç›´æ¨æ•°é‡å¤±è´¥:', e.message);
                            }
                        }
                    } catch (e) {
                        console.warn('è·å–æ¨èå…³ç³»å¤±è´¥:', e.message);
                    }

                    // è®¡ç®—ç»Ÿè®¡æ•°æ®
                    const totalReferralRewards = result.referralRewards.reduce((sum, r) => sum + parseFloat(r.usdtAmount), 0);
                    const totalSystemFees = result.systemAllocations.reduce((sum, a) => sum + parseFloat(a.amount), 0);
                    const remainingFunds = totalUSDTAmount - totalReferralRewards - totalSystemFees;
                    const totalReferralHashPower = result.referralRewards.reduce((sum, r) => sum + parseFloat(r.hashPowerAmount), 0);

                    result.summary = {
                        totalReferralRewards: totalReferralRewards.toFixed(4),
                        referralPercentage: ((totalReferralRewards / totalUSDTAmount) * 100).toFixed(2),
                        totalSystemFees: totalSystemFees.toFixed(4),
                        systemPercentage: ((totalSystemFees / totalUSDTAmount) * 100).toFixed(2),
                        remainingFunds: remainingFunds.toFixed(4),
                        remainingPercentage: ((remainingFunds / totalUSDTAmount) * 100).toFixed(2),
                        userHashPowerGain: userHashPower.toFixed(0),
                        totalReferralHashPower: totalReferralHashPower.toFixed(0)
                    };

                    return result;
                }

                // è·å–å¥–åŠ±ç±»å‹å¯¹åº”çš„é¢œè‰²
                function getRewardColor(type) {
                    const colorMap = {
                        'ç›´æ¨å¥–åŠ±': '#28a745',
                        '2ä»£å¥–åŠ±': '#17a2b8',
                        '3ä»£å¥–åŠ±': '#20c997',
                        '4ä»£å¥–åŠ±': '#6f42c1',
                        '5ä»£å¥–åŠ±': '#e83e8c',
                        'æŠ€æœ¯å›¢é˜Ÿ': '#fd7e14',
                        'è¿è¥å›¢é˜Ÿ': '#ffc107',
                        'èŠ‚ç‚¹åˆ†çº¢æ± ': '#6610f2',
                        'å¤‡ç”¨é‡‘': '#dc3545',
                        'è–„é¥¼ä¹°å¸æ³¨å…¥LP': '#fd7e14',
                        'èŠ‚ç‚¹æ± åˆ†çº¢': '#fd7e14',
                        'é—´æ¨å¥–åŠ± (èŠ‚ç‚¹)': '#17a2b8',
                        'é»˜è®¤': '#6c757d'
                    };

                    // å¤„ç†åŠ¨æ€ç”Ÿæˆçš„å¤šä»£å¥–åŠ±é¢œè‰²
                    if (type.includes('ä»£å¥–åŠ±') && !colorMap[type]) {
                        const colors = ['#17a2b8', '#20c997', '#6f42c1', '#e83e8c', '#fd7e14', '#ffc107'];
                        const level = parseInt(type.match(/\d+/)[0]);
                        return colors[(level - 2) % colors.length];
                    }

                    return colorMap[type] || colorMap['é»˜è®¤'];
                }

                async function fetchDestroyInfo() {
                    render('destroyInfoResult', '<div class="loader"></div>æ­£åœ¨æŸ¥è¯¢é”€æ¯æœºåˆ¶ä¸å¤‡ç”¨é‡‘ä¿¡æ¯...');

                    try {
                        // è·å–é”€æ¯ç›¸å…³æ•°æ®
                        // æ³¨æ„: getDestroyReserve å’Œ lastDestroyTime åœ¨å½“å‰ABIä¸­ä¸å­˜åœ¨ï¼Œæš‚æ—¶ç§»é™¤
                        const [
                            burnedBalance,
                            axmPrice,
                            poolUSDTBalance
                        ] = await Promise.all([
                            contracts.token.balanceOf(config.burnAddress),
                            contracts.pool.getAXMPrice(),
                            contracts.usdt.balanceOf(config.poolAddress)
                        ]);

                        // ä¸ºç¼ºå¤±çš„åˆçº¦å‡½æ•°æä¾›é»˜è®¤å€¼
                        const destroyReserve = ethers.BigNumber.from(0);
                        const lastDestroyTime = ethers.BigNumber.from(0);

                        const destroyData = {
                            'å·²é”€æ¯FCLæ€»é‡': `${format(burnedBalance)} FCL`,
                            'é”€æ¯åœ°å€': `<code>0x000000000000000000000000000000000000dEaD</code>`,
                            'å½“å‰FCLä»·æ ¼': `${format(axmPrice, 18)} USDT`,
                            'ä¸Šæ¬¡é”€æ¯æ—¶é—´': lastDestroyTime.toNumber() > 0 ? new Date(lastDestroyTime.toNumber() * 1000).toLocaleString('zh-CN') : 'ä»æœªæ‰§è¡Œ'
                        };

                        // å¤‡ç”¨é‡‘ä¿¡æ¯
                        const reserveData = {
                            'å½“å‰å¤‡ç”¨é‡‘': `${format(destroyReserve, 18)} USDT`,
                            'çŸ¿æ± USDTä½™é¢': `${format(poolUSDTBalance, 18)} USDT`,
                            'å¤‡ç”¨é‡‘å æ¯”': `${poolUSDTBalance.gt(0) ? (parseFloat(format(destroyReserve, 18)) / parseFloat(format(poolUSDTBalance, 18)) * 100).toFixed(2) : '0'}%`
                        };

                        // é”€æ¯æœºåˆ¶è¯´æ˜
                        const mechanismHtml = `
                    <div class="destroy-mechanism" style="margin: 15px 0;">
                        <h4>ğŸ”¥ æ¯æ—¥é”€æ¯æœºåˆ¶è¯´æ˜</h4>
                        <div style="background: rgba(220, 53, 69, 0.1); border-radius: 8px; padding: 15px; border-left: 4px solid #dc3545;">
                            <div style="margin: 8px 0;"><strong>è§¦å‘æ¡ä»¶:</strong></div>
                            <div style="margin-left: 15px;">â€¢ FCLä»·æ ¼ â‰¥ 10 USDT</div>
                            <div style="margin-left: 15px;">â€¢ è·ç¦»ä¸Šæ¬¡é”€æ¯ â‰¥ 24å°æ—¶</div>
                            <div style="margin-left: 15px;">â€¢ å¤‡ç”¨é‡‘ä½™é¢å……è¶³</div>
                            
                            <div style="margin: 12px 0 8px 0;"><strong>é”€æ¯è§„åˆ™:</strong></div>
                            <div style="margin-left: 15px;">â€¢ é”€æ¯æ•°é‡ = çŸ¿æ± USDTä½™é¢çš„1%çš„50%</div>
                            <div style="margin-left: 15px;">â€¢ ä½¿ç”¨å¤‡ç”¨é‡‘åœ¨è–„é¥¼V2è´­ä¹°FCL</div>
                            <div style="margin-left: 15px;">â€¢ ç›´æ¥ä¹°å…¥åˆ°é”€æ¯åœ°å€ (0x...dEaD)</div>
                            
                            <div style="margin: 12px 0 8px 0;"><strong>å¤‡ç”¨é‡‘æ¥æº:</strong></div>
                            <div style="margin-left: 15px;">â€¢ æ¯ç¬”å…¥é‡‘çš„5%è‡ªåŠ¨ç´¯ç§¯</div>
                            <div style="margin-left: 15px;">â€¢ ä¸“é—¨ç”¨äºå›è´­é”€æ¯æœºåˆ¶</div>
                        </div>
                    </div>
                `;

                        // è®¡ç®—ä¸‹æ¬¡å¯é”€æ¯çš„æ¡ä»¶
                        const currentTime = Math.floor(Date.now() / 1000);
                        const nextDestroyTime = lastDestroyTime.toNumber() + 86400; // 24å°æ—¶å
                        const canDestroyTime = nextDestroyTime > currentTime;
                        const priceReached = parseFloat(format(axmPrice, 18)) >= 10;
                        const hasReserve = destroyReserve.gt(0);

                        const nextDestroyHtml = `
                    <div class="next-destroy" style="margin: 15px 0; padding: 15px; background: rgba(23, 162, 184, 0.1); border-radius: 8px; border-left: 4px solid #17a2b8;">
                        <h4>â° ä¸‹æ¬¡é”€æ¯é¢„æµ‹</h4>
                        <div class="condition-check">
                            <div style="margin: 5px 0;">
                                <span style="color: ${priceReached ? '#28a745' : '#dc3545'};">
                                    ${priceReached ? 'âœ…' : 'âŒ'} ä»·æ ¼æ¡ä»¶: ${format(axmPrice, 18)} USDT ${priceReached ? 'â‰¥' : '<'} 10 USDT
                                </span>
                            </div>
                            <div style="margin: 5px 0;">
                                <span style="color: ${!canDestroyTime ? '#28a745' : '#dc3545'};">
                                    ${!canDestroyTime ? 'âœ…' : 'âŒ'} æ—¶é—´æ¡ä»¶: ${canDestroyTime ? `è¿˜éœ€ç­‰å¾… ${Math.ceil((nextDestroyTime - currentTime) / 3600)} å°æ—¶` : 'å¯ä»¥æ‰§è¡Œ'}
                                </span>
                            </div>
                            <div style="margin: 5px 0;">
                                <span style="color: ${hasReserve ? '#28a745' : '#dc3545'};">
                                    ${hasReserve ? 'âœ…' : 'âŒ'} å¤‡ç”¨é‡‘å……è¶³: ${format(destroyReserve, 18)} USDT
                                </span>
                            </div>
                        </div>
                        
                        ${priceReached && !canDestroyTime && hasReserve ?
                                `<div style="margin-top: 10px; padding: 10px; background: rgba(40, 167, 69, 0.2); border-radius: 5px; color: #155724;">
                                <strong>ğŸ‰ æ»¡è¶³é”€æ¯æ¡ä»¶ï¼ä¸‹æ¬¡æœ‰ç”¨æˆ·å…¥é‡‘æ—¶å°†è‡ªåŠ¨è§¦å‘é”€æ¯</strong>
                            </div>` :
                                `<div style="margin-top: 10px; padding: 10px; background: rgba(255, 193, 7, 0.2); border-radius: 5px; color: #856404;">
                                <strong>â³ æš‚ä¸æ»¡è¶³é”€æ¯æ¡ä»¶ï¼Œéœ€ç­‰å¾…æ‰€æœ‰æ¡ä»¶æ»¡è¶³</strong>
                            </div>`
                            }
                    </div>
                `;

                        render('destroyInfoResult',
                            createCard('ğŸ”¥ é”€æ¯æ•°æ®', destroyData) +
                            createCard('ğŸ’° å¤‡ç”¨é‡‘çŠ¶æ€', reserveData) +
                            mechanismHtml +
                            nextDestroyHtml
                        );

                    } catch (e) {
                        console.error('Error fetching destroy info:', e);
                        render('destroyInfoResult', showError('æŸ¥è¯¢é”€æ¯ä¿¡æ¯æ—¶å‡ºé”™: ' + e.message));
                    }
                }

                async function fetchMarketInfo() {
                    let marketData = {}, lpData = {};
                    try {
                        const [
                            totalSupply, burnedBalance, axmInPool, usdtInPool,
                            lpReserves, lpToken0, usdtDecimals
                        ] = await Promise.all([
                            contracts.token.totalSupply(),
                            contracts.token.balanceOf(config.burnAddress),
                            contracts.token.balanceOf(config.poolAddress),
                            contracts.usdt.balanceOf(config.poolAddress),
                            contracts.lp.getReserves(),
                            contracts.lp.token0(),
                            contracts.usdt.decimals()
                        ]);

                        // Market Data
                        marketData = {
                            'æ€»ä¾›åº”é‡': `${format(totalSupply)} FCL`,
                            'æ€»é”€æ¯é‡': `${format(burnedBalance)} FCL`,
                            'æµé€šé‡': `${format(totalSupply.sub(burnedBalance))} FCL`,
                            'çŸ¿æ± FCLä½™é¢': `<b>${format(axmInPool)} FCL</b>`,
                            'çŸ¿æ± USDTä½™é¢': `<b>${format(usdtInPool, usdtDecimals)} USDT</b>`
                        };

                        // LP Data
                        const axmIsToken0 = lpToken0.toLowerCase() === config.axmTokenAddress.toLowerCase();
                        const axmReserve = axmIsToken0 ? lpReserves._reserve0 : lpReserves._reserve1;
                        const usdtReserve = axmIsToken0 ? lpReserves._reserve1 : lpReserves._reserve0;

                        if (axmReserve.gt(0) && usdtReserve.gt(0)) {
                            const price = parseFloat(format(usdtReserve, usdtDecimals)) / parseFloat(format(axmReserve));
                            lpData = {
                                'FCL å‚¨å¤‡': `${format(axmReserve)} FCL`,
                                'USDT å‚¨å¤‡': `${format(usdtReserve, usdtDecimals)} USDT`,
                                'å½“å‰ä»·æ ¼': `1 FCL â‰ˆ ${price.toFixed(6)} USDT`,
                                'å¸‚å€¼ä¼°ç®—': `${(parseFloat(format(totalSupply.sub(burnedBalance))) * price).toFixed(2)} USDT`
                            };
                        } else {
                            lpData = {
                                'FCL å‚¨å¤‡': '0 FCL',
                                'USDT å‚¨å¤‡': '0 USDT',
                                'å½“å‰ä»·æ ¼': 'æš‚æ— æµåŠ¨æ€§',
                                'å¸‚å€¼ä¼°ç®—': '0 USDT'
                            };
                        }

                    } catch (e) {
                        console.error('Error fetching market info:', e);
                        marketData['é”™è¯¯'] = showError('æ— æ³•è·å–å¸‚åœºä¿¡æ¯');
                        lpData['é”™è¯¯'] = showError('æ— æ³•è·å–LPæ± ä¿¡æ¯');
                    }
                    render('marketInfoResult', createCard('ğŸ“ˆ ä»£å¸ç»æµ', marketData) + createCard('ğŸ’§ LPæµåŠ¨æ€§æ± ', lpData));
                }

                async function fetchContractInfo() {
                    let contractData = {}, addressData = {};
                    try {
                        // ä¸»ç½‘åœ°å€æœ‰æ•ˆæ€§æ ¡éªŒï¼šç¡®ä¿åœ°å€ä¸Šå·²éƒ¨ç½²åˆçº¦
                        const poolCode = await provider.getCode(config.poolAddress);
                        if (!poolCode || poolCode === '0x') {
                            throw new Error('Pool address has no contract code on mainnet');
                        }

                        // å®‰å…¨è¯»å–å°è£…ï¼Œé¿å…ABIæˆ–åœ°å€ä¸åŒ¹é…é€ æˆé¡µé¢æŠ¥é”™
                        const safeRead = async (fn) => {
                            try {
                                return await fn();
                            } catch (err) {
                                console.warn('Safe read failed:', err);
                                return null;
                            }
                        };

                        // å°è¯•å¤šç§å‘½åå˜ä½“è¯»å–ï¼ˆä¾‹å¦‚ minDeposit æˆ– MIN_DEPOSITï¼‰ä»¥æé«˜å…¼å®¹æ€§
                        const tryReadVariant = async (variants) => {
                            for (const v of variants) {
                                try {
                                    if (typeof v === 'function') {
                                        const res = await v();
                                        if (res !== null && res !== undefined) return res;
                                    }
                                } catch (e) {
                                    // å¿½ç•¥å•ä¸ªå˜ä½“çš„é”™è¯¯ï¼Œç»§ç»­å°è¯•å…¶ä»–å˜ä½“
                                    console.warn('Variant read failed:', e.message || e);
                                }
                            }
                            return null;
                        };

                        const [
                            minDeposit, maxDeposit, nodeDeposit
                        ] = await Promise.all([
                            tryReadVariant([() => contracts.pool.minDeposit(), () => contracts.pool.MIN_DEPOSIT()]),
                            tryReadVariant([() => contracts.pool.maxDeposit(), () => contracts.pool.MAX_DEPOSIT()]),
                            tryReadVariant([() => contracts.pool.nodeDeposit(), () => contracts.pool.NODE_DEPOSIT()])
                        ]);

                        // å…¶ä»–å¸¸é‡ä»ä½¿ç”¨åŸæœ‰safeRead
                        const [totalMinable, maxProduction, endMiningThreshold, bnbToHashpowerRate] = await Promise.all([
                            safeRead(() => contracts.pool.TOTAL_MINABLE()),
                            safeRead(() => contracts.pool.MAX_PRODUCTION()),
                            safeRead(() => contracts.pool.END_MINING_THRESHOLD()),
                            safeRead(() => contracts.pool.BNB_TO_HASHPOWER_RATE())
                        ]);

                        contractData = {
                            'æœ€å°å…¥é‡‘': minDeposit ? `${format(minDeposit, 18, 4)} BNB` : 'è¯»å–å¤±è´¥ï¼ˆå¯èƒ½ABI/åœ°å€ä¸åŒ¹é…ï¼‰',
                            'æœ€å¤§å…¥é‡‘': maxDeposit ? `${format(maxDeposit, 18, 2)} BNB` : 'è¯»å–å¤±è´¥ï¼ˆå¯èƒ½ABI/åœ°å€ä¸åŒ¹é…ï¼‰',
                            'èŠ‚ç‚¹è´¨æŠ¼é¢': nodeDeposit ? `${format(nodeDeposit, 18, 2)} BNB` : 'è¯»å–å¤±è´¥ï¼ˆå¯èƒ½ABI/åœ°å€ä¸åŒ¹é…ï¼‰',
                            'æ€»å¯æŒ–çŸ¿é‡': totalMinable ? `${format(totalMinable)} FCL` : 'è¯»å–å¤±è´¥ï¼ˆå¯èƒ½ABI/åœ°å€ä¸åŒ¹é…ï¼‰',
                            'æœ€å¤§äº§å‡ºé™åˆ¶': maxProduction ? `${format(maxProduction)} FCL` : 'è¯»å–å¤±è´¥ï¼ˆå¯èƒ½ABI/åœ°å€ä¸åŒ¹é…ï¼‰',
                            'ç»“æŸæŒ–çŸ¿é˜ˆå€¼': endMiningThreshold ? `${format(endMiningThreshold)} FCL` : 'è¯»å–å¤±è´¥ï¼ˆå¯èƒ½ABI/åœ°å€ä¸åŒ¹é…ï¼‰',
                            '1BNBç®—åŠ›æ¯”ç‡': bnbToHashpowerRate ? bnbToHashpowerRate.toString() : 'è¯»å–å¤±è´¥ï¼ˆå¯èƒ½ABI/åœ°å€ä¸åŒ¹é…ï¼‰'
                        };

                        addressData = {
                            'çŸ¿æ± åˆçº¦': `<code title="ç‚¹å‡»å¤åˆ¶" onclick="copyToClipboard('${config.poolAddress}')">${config.poolAddress}</code>`,
                            'FCLä»£å¸': `<code title="ç‚¹å‡»å¤åˆ¶" onclick="copyToClipboard('${config.axmTokenAddress}')">${config.axmTokenAddress}</code>`,
                            'ç»‘å®šåˆçº¦': `<code title="ç‚¹å‡»å¤åˆ¶" onclick="copyToClipboard('${config.bindContractAddress}')">${config.bindContractAddress}</code>`,
                            'USDTåˆçº¦': `<code title="ç‚¹å‡»å¤åˆ¶" onclick="copyToClipboard('${config.usdtAddress}')">${config.usdtAddress}</code>`,
                            'LPæ± åœ°å€': `<code title="ç‚¹å‡»å¤åˆ¶" onclick="copyToClipboard('${config.lpPairAddress}')">${config.lpPairAddress}</code>`,
                            'èŠ‚ç‚¹åˆçº¦': `<code title="ç‚¹å‡»å¤åˆ¶" onclick="copyToClipboard('${config.nodePoolAddress}')">${config.nodePoolAddress}</code>`
                        };

                    } catch (e) {
                        console.error('Error fetching contract info:', e);
                        // æ›´æ˜ç¡®çš„é”™è¯¯æç¤ºï¼šä¸»ç½‘åœ°å€æ— åˆçº¦æˆ–ABIä¸åŒ¹é…
                        const isNoCode = /no contract code/i.test(e.message) || /has no contract code/i.test(e.message);
                        contractData['é”™è¯¯'] = showError(isNoCode ? 'ä¸»ç½‘åœ°å€æœªéƒ¨ç½²åˆçº¦ï¼Œè¯·ç¡®è®¤åˆçº¦åœ°å€' : 'æ— æ³•è·å–åˆçº¦å‚æ•°ï¼ˆå¯èƒ½ABI/åœ°å€ä¸åŒ¹é…ï¼‰');
                        addressData['é”™è¯¯'] = showError('æ— æ³•è·å–åˆçº¦åœ°å€');
                    }
                    render('contractInfoResult', createCard('âš™ï¸ åˆçº¦å‚æ•°', contractData) + createCard('ğŸ“ åˆçº¦åœ°å€', addressData));
                }

                async function fetchMiningInfo() {
                    let miningData = {}, hashpowerData = {};
                    try {
                        const [
                            totalStaticHashPower, totalDynamicHashPower, totalMined,
                            miningStarted, miningStartTime
                        ] = await Promise.all([
                            contracts.pool.totalStaticHashPower(),
                            contracts.pool.totalDynamicHashPower(),
                            contracts.pool.totalMined(),
                            contracts.pool.miningStarted(),
                            contracts.pool.miningStartTime()
                        ]);

                        // è®¡ç®—æŒ–çŸ¿åˆ†é…ç›¸å…³ä¿¡æ¯
                        let nextDistributionTime = 'å°šæœªå¼€å§‹';
                        let distributionCount = 0;
                        let currentPeriodProduction = 0;
                        let calculatedTotalMined = 0; // è®¡ç®—å¾—å‡ºçš„æ€»æŒ–çŸ¿é‡

                        if (miningStarted && !miningStartTime.eq(0)) {
                            const now = Math.floor(Date.now() / 1000);
                            const startTime = miningStartTime.toNumber();

                            // è®¡ç®—å·²ç»è¿‡å»çš„30åˆ†é’Ÿå‘¨æœŸæ•°
                            const elapsedTime = now - startTime;
                            const periodDuration = 24 * 60 * 60; // 24å°æ—¶

                            distributionCount = Math.floor(elapsedTime / periodDuration);

                            // è®¡ç®—ä¸‹æ¬¡åˆ†é…æ—¶é—´
                            const nextPeriodStart = startTime + (distributionCount + 1) * periodDuration;
                            nextDistributionTime = new Date(nextPeriodStart * 1000).toLocaleString('zh-CN');

                            // è·å–å½“å‰å‘¨æœŸçš„äº§é‡
                            try {
                                currentPeriodProduction = await contracts.pool.getCurrentDailyProduction();
                            } catch (e) {
                                console.warn('æ— æ³•è·å–å½“å‰å‘¨æœŸäº§é‡:', e.message);
                            }

                            // è®¡ç®—æ€»æŒ–çŸ¿é‡ï¼šç´¯è®¡æ‰€æœ‰å·²å®Œæˆå‘¨æœŸçš„äº§é‡
                            calculatedTotalMined = 0;
                            for (let period = 0; period < distributionCount; period++) {
                                // è®¡ç®—æ¯ä¸ªå‘¨æœŸå±äºç¬¬å‡ ä¸ªæœˆ
                                const monthIndex = Math.floor(period / 30);

                                // é¦–æœŸï¼ˆç¬¬0ä¸ªæœˆï¼‰äº§é‡ï¼š1000æš
                                let monthProduction = 1000;

                                // ä»ç¬¬äºŒæœŸï¼ˆç¬¬1ä¸ªæœˆï¼‰å¼€å§‹ï¼Œæ¯æœˆäº§é‡å¢åŠ 5%
                                for (let i = 1; i <= monthIndex; i++) {
                                    monthProduction = monthProduction * 1.05; // å¢åŠ 5%
                                }

                                // å•ä¸ªå‘¨æœŸçš„äº§é‡ï¼ˆæœˆäº§é‡é™¤ä»¥30ä¸ªå‘¨æœŸï¼‰
                                const periodProduction = monthProduction / 30;
                                calculatedTotalMined += periodProduction;
                            }
                        }

                        miningData = {
                            'æŒ–çŸ¿çŠ¶æ€': miningStarted ? 'âœ… å·²å¼€å§‹' : 'âŒ æœªå¼€å§‹',
                            'å¼€å§‹æ—¶é—´': miningStartTime.eq(0) ? 'å°šæœªå¼€å§‹' : new Date(miningStartTime.toNumber() * 1000).toLocaleString('zh-CN'),
                            'ä¸‹æ¬¡åˆ†é…æ—¶é—´': nextDistributionTime,
                            'å·²åˆ†é…æ¬¡æ•°': `${distributionCount} æ¬¡`,
                            'å½“å‰å‘¨æœŸäº§é‡': `${format(currentPeriodProduction || 0)} FCL`,
                            'å·²æŒ–æ€»é‡(è®¡ç®—)': `${calculatedTotalMined.toFixed(4)} FCL`,
                            'å·²é¢†å–æ€»é‡(åˆçº¦)': `${format(totalMined)} FCL`,
                            'å‰©ä½™å¯æŒ–': `${format(ethers.BigNumber.from('95219000000000000000000').sub(totalMined))} FCL`
                        };

                        hashpowerData = {
                            'å…¨ç½‘é™æ€ç®—åŠ›': format(totalStaticHashPower, 18),
                            'å…¨ç½‘åŠ¨æ€ç®—åŠ›': format(totalDynamicHashPower, 18),
                            'æ€»ç®—åŠ›': format(totalStaticHashPower.add(totalDynamicHashPower), 18),
                            'ç®—åŠ›å¯†åº¦': totalStaticHashPower.add(totalDynamicHashPower).gt(0) ?
                                `${format(totalMined.mul(10000).div(totalStaticHashPower.add(totalDynamicHashPower)), 2)} FCL/ç®—åŠ›` : '0'
                        };

                    } catch (e) {
                        console.error('Error fetching mining info:', e);
                        miningData['é”™è¯¯'] = showError('æ— æ³•è·å–æŒ–çŸ¿ä¿¡æ¯');
                        hashpowerData['é”™è¯¯'] = showError('æ— æ³•è·å–ç®—åŠ›ä¿¡æ¯');
                    }
                    render('miningInfoResult', createCard('â›ï¸ æŒ–çŸ¿çŠ¶æ€', miningData) + createCard('ğŸ’ª å…¨ç½‘ç®—åŠ›', hashpowerData));
                }

                // --- æµ‹è¯•åŠŸèƒ½å‡½æ•° ---










                // å·¥å…·å‡½æ•°ï¼šå¤åˆ¶åˆ°å‰ªè´´æ¿
                function copyToClipboard(text) {
                    navigator.clipboard.writeText(text).then(() => {
                        alert('åœ°å€å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼');
                    }).catch(err => {
                        console.error('å¤åˆ¶å¤±è´¥:', err);
                        // å¤‡ç”¨æ–¹æ¡ˆ
                        const textArea = document.createElement('textarea');
                        textArea.value = text;
                        document.body.appendChild(textArea);
                        textArea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textArea);
                        alert('åœ°å€å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼');
                    });
                }
            </script>
</body>

</html>
